
import math
import numpy as np
from abc import ABC
import healpy

from astropy.coordinates import SkyCoord

from .chunker import Chunker

__all__ = ["ColumnGenerator", "ObjIdGenerator", "FilterGenerator",
           "RaDecGenerator", "MagnitudeGenerator", "ForcedSourceGenerator",
           "VisitIdGenerator", "mergeBlocks"]


def calcSeedFrom(chunk_id, seed, column_val):
    """Try to keep some separation between column generator seeds.

    Parameters
    ----------
    chunk_id : int
        Chunk id number.
    seed : int
        Random number seed.
    column_val : int
        Arbitrary column value, should be different from other column values.

    Note
    ----
    This is an attempt to avoid having chunks and columns having seeds
    near each other so that changing the seed value by 1 will not look
    like everyting was just shifted over by 1 chunk/column.
    Each ColumnGenerator should have a unique arbitrary column_val.
    """
    return (chunk_id*10000 + seed + column_val*100)


def mergeBlocks(block_a, block_b):
    """Merge two block together where the lists should maintain the order of
    the individual elements.

    Parameters
    ----------
    block_a, block_b : tuple of lists
        Blocks of data generated by column generators.

    Return
    ------
    Tuple of lists
        Result of merging the two blocks.
    """
    return tuple(np.concatenate(x) for x in zip(block_a, block_b))


def convertBlockToRows(block):
    """Transpose the block.

    Return
    ------
    tuple of lists
        A new block where columns of 'block' are the rows of the output block.
    """
    rows = []
    rows_in_block = len(block[0])
    for j in range(rows_in_block):
        row = []
        for x in block:
            if len(x) != rows_in_block:
                raise IndexError
            row.append(x[j])
        rows.append(row)
    return rows


def containsBlock(block_a, block_b):
    """Return True if every row in blockA has a matching row in blockB.
    The data is stored in columns and it is easier to do the
    comparison using rows.
    """
    if len(block_a) != len(block_b):
        return False
    if len(block_a) == 0:
        return True

    # Convert blockA into a list of rows.
    try:
        rows_a = convertBlockToRows(block_a)
        rows_b = convertBlockToRows(block_b)
        for row in rows_a:
            # if the row is found in rowsB, delete it in rowsB
            found = False
            for j in range(len(rows_b)):
                if row == rows_b[j]:
                    found = True
                    print("found row ", row)
                    del rows_b[j]
                    break
            if not found:
                print("missing row ", row)
                return False

    except IndexError:
        print("Malformed block A=", block_a, " B=", block_b)
        return False
    return True


class SimpleBox:
    """
    A simple RA DEC box where raA is always smaller than raB and
    decA is always smaller than decB and the units are degrees.

    Parameters
    ----------
    raA, raB : float
        RA of two opposite corners of the box.
    decA, decB : float
        Declination of two opposite corners of the box.

    Note
    ----
    This has no internal mechanism to fix wrap around from 360 to 0, so a
    box that includes lon 0 should go from -1 to 1 not 359 to 1.
    Dec values are constrained [-90, 90]
    """
    def __init__(self, raA, raB, decA, decB):
        self.raA = raA
        self.raB = raB
        self.decA = decA
        self.decB = decB
        if (raA > raB):
            tmp = raA
            raA = raB
            raB = tmp
        if (decA > decB):
            tmp = decA
            decA = decB
            decB = tmp
        if (decA > 90.0):
            decA = 90.0
        if (decA < -90.0):
            decA = -90.0
        if (decB > 90.0):
            decB = 90.0
        if (decB < -90.0):
            decB = -90.0

    def __repr__(self):
        return ('{raA=' + str(self.raA) + ' raB=' + str(self.raB) +
                ' decA=' + str(self.decA) + ' decB=' + str(self.decB) + '}')

    def __str__(self):
        return self.__repr__()

    def area(self):
        """
        Return
        ------
        area : float degrees
        Returns the approximate area of the box on a sphere, requires degrees
        """
        area = (self.raA - self.raB) * (self.decA - self.decB)
        avgDecDeg = (self.decA + self.decB) / 2
        avgDecRad = avgDecDeg * (math.pi/180.0)
        area = math.cos(avgDecRad) * area
        return area


class ColumnGenerator(ABC):

    def __call__(self, chunk_id, length, seed):
        """
        Parameters
        ----------
        chunk_id : int
            Identifier of which cell on the sky to in which
            coordinates should be generated
        length : int
            Number of coordiantes to generate
        seed : int
            Seed value for the random number generator to
            generate repeatable results.

        Returns
        -------
        columns: tuple
            One or more arrays containing the data for each column
        """
        return NotImplemented


class RaDecGenerator(ColumnGenerator):
    """This class generate pseudorandom repeatanble RA and Declination.


    Parameters
    ----------
    chunker : sphgeom.Chunker
        Chunker to provide RA and Dec limits of a chunk.
    ignore_edge_only : bool
        Generate the entire chunk's worth of RA and Dec even if edge_only
        is specified.

    Note
    ----
    It starts by generating edges first so edge_only and complete chunks
    will have matching edges.
    """
    def __init__(self, chunker, ignore_edge_only=False):
        self.chunker = chunker
        self.ignore_edge_only = ignore_edge_only
        self.columnVal = 1
        # avoid having the same ra and dec in different tables.
        if self.ignore_edge_only:
            self.columnVal = 2

    def _generateBlock(self, chunk_id, simple_box, length):
        """ Generate 'length' number of RA and Dec data entries for 'simpleBox'

        Parameters
        ----------
        chunk_id : int
            Chunk id number.
        simple_box : SimpleBox
            Defines min and max legal RA and Dec to be generated.

        Returns
        -------
        tuple of list of generated RA's and list of generated Dec's
        """
        ra_min = simple_box.raA
        ra_delta = simple_box.raB - simple_box.raA
        dec_min = simple_box.decA
        dec_delta = simple_box.decB - simple_box.decA
        ra_centers = np.random.random(length)*ra_delta + ra_min
        dec_centers = np.random.random(length)*dec_delta + dec_min
        ra_out = []
        for ra in ra_centers:
            while ra < 0.0:
                ra += 360.0
            while ra >= 360.0:
                ra -= 360.0
            ra_out.append(ra)
        return (ra_out, dec_centers)

    def __call__(self, chunk_id, length, seed, edge_width=0.0, edge_only=False):
        """
        Parameters
        ----------
        chunk_id : int
            Chunk id number where RA and Dec values are needed.
        length : int
            Number of coordiantes to generate.
        seed : int
            Random number seed.
        edge_width : float degrees, optional
            Width of the edge generated. Must be wide enough to cover
            overlap and must be consistent throughout chunk generation.
        edge_only : bool, optional
            When True, only generate the values near edges of chunks,
            edge_width. Otherwise, generate edge values first and then
            generate values for the middle of the chunk.

        Returns
        -------
        a tuple of a list of generated RA's and a list of generated Dec's.
        """
        np.random.seed(calcSeedFrom(chunk_id, seed, self.columnVal))

        # Some tables, such as ccdVisit, cannot be generated edgeOnly.
        if self.ignore_edge_only:
            edge_only = False

        # sphgeom Box from Chunker::getChunkBoundingBox
        chunk_box = self.chunker.getChunkBounds(chunk_id)
        # Need to correct for RA that crosses 0.
        raA = chunk_box.getLon().getA().asDegrees()
        raB = chunk_box.getLon().getB().asDegrees()
        ra_delta = raB - raA
        if ra_delta < 0:
            raA = raA - 360.0
            ra_delta = raB - raA
        decA = chunk_box.getLat().getA().asDegrees()
        decB = chunk_box.getLat().getB().asDegrees()

        boxes = {}
        entire_box = SimpleBox(raA, raB, decA, decB)
        boxes["entire"] = entire_box
        print("chunk=", chunk_id, "bbox=", entire_box.__repr__())

        if edge_width > 0.0:
            # Correct the edge_width for declination so there is at least
            # edge_width at both the top an bottom of the east and west blocks.
            edge_raA = edge_width / math.cos(decA + edge_width)
            edge_raB = edge_width / math.cos(decB - edge_width)
            edge_widthRA = max(edge_raA, edge_raB)

            boxes["north"] = SimpleBox(raA, raB, decB - edge_width, decB)
            boxes["east"] = SimpleBox(raA, raA + edge_widthRA, decA + edge_width, decB - edge_width)
            boxes["west"] = SimpleBox(raB - edge_widthRA, raB, decA + edge_width, decB - edge_width)
            boxes["south"] = SimpleBox(raA, raB, decA, decA + edge_width)

        # If the area of the entire box is only slightly larger than the sub-boxes,
        # don't bother with separate edge calculation
        edge_area = 0.0
        entire_area = 0.0
        for key, value in boxes.items():
            if key == "entire":
                entire_area = value.area()
            else:
                edge_area += value.area()

        ratio_edge_to_entire = edge_area/entire_area
        blocks = {}
        # TODO: replace 10 with minLength and 0.90 with maxRatioEdgeToEntire
        if (not edge_width > 0.0) or ratio_edge_to_entire > 0.90 or length < 10:
            # Just generate the entire block
            blocks["entire"] = self._generateBlock(chunk_id, boxes["entire"], length)
        else:
            lengths = {}
            sub_length = length
            for key, value in boxes.items():
                if key != "entire":
                    lengths[key] = int((value.area()/entire_area) * length)
                    if lengths[key] < 1:
                        lengths[key] = 1
                    sub_length -= lengths[key]
                    blocks[key] = self._generateBlock(chunk_id, boxes[key], lengths[key])
            blockNS = mergeBlocks(blocks["north"], blocks["south"])
            blockEW = mergeBlocks(blocks["east"], blocks["west"])
            blocks["entire"] = mergeBlocks(blockNS, blockEW)
            if not edge_only:
                box_middle = SimpleBox(boxes["east"].raB, boxes["west"].raA,
                                       boxes["north"].decB, boxes["south"].decA)
                block_middle = self._generateBlock(chunk_id, box_middle, sub_length)
                blocks["entire"] = mergeBlocks(blocks["entire"], block_middle)
        return blocks["entire"]


class ObjIdGenerator(ColumnGenerator):

    def __call__(self, chunk_id, length, seed, **kwargs):
        """
        Returns
        -------
        object_id : array
            Array containing unique IDs for each object
        """

        # TODO: more than 100k objects in a chunk will cause issues
        #       Replace 100000 with max_objects_per_chunk?
        return (chunk_id * 100000) + np.arange(length)


class VisitIdGenerator(ColumnGenerator):

    def __call__(self, chunk_id, length, seed, **kwargs):
        """
        Returns
        -------
        visit_id : array
            Array containing unique IDs for each visit
        """

        # TODO: This shouldn't have the same issue as objects/chunk
        #       but maybe replace 100000 with max_objects_per_chunk?
        return 10000000000 + (chunk_id * 100000) + np.arange(length)


class MagnitudeGenerator(ColumnGenerator):
    """
    Parameters
    ----------
    n_mags : int
        Number of magnitude columns to make.
    min_mag : float
        Minimum value for generated magnitudes.
    max_mag : float
        Maximum value for generated magnitudes.
    column_val : int
        Arbitrary integer that should be different from other
        column values. Used in random number generation.

    Note
    ----
    Currently generates a flat magnitude distribution. Should properly
    be some power law.
    If there is more than one call to this in a single table, there will
    be correlation between rows as the same random numbers will be used.
    """

    def __init__(self, n_mags=1, min_mag=0, max_mag=27.5, column_val=7):
        self.n_mags = n_mags
        self.min_mag = min_mag
        self.max_mag = max_mag
        self.column_val = column_val  # arbitrary, but different from other columns

    def __call__(self, chunk_id, length, seed, **kwargs):

        np.random.seed(calcSeedFrom(chunk_id, seed, self.column_val))

        # This needs to be made row by row not column by column, as
        # row by row results in repeatable values when doing edges first.
        magRows = []
        delta_mag = self.max_mag - self.min_mag
        for unused in range(length):
            mag = np.random.rand(self.n_mags)*delta_mag + self.min_mag
            magRows.append(mag)
        magCols = convertBlockToRows(magRows)
        return magCols


class FilterGenerator(ColumnGenerator):
    """Class to generate random filter columns.

    Parameters
    ----------
    filters : str
        String where each character is a valid filter id.
    column_val : int
        Arbitrary integer that should be different from other
        column values. Used in random number generation.
    """

    def __init__(self, filters="ugrizy", column_val=6):
        self.filters = filters
        self.column_val = column_val

    def __call__(self, chunk_id, length, seed, **kwargs):
        np.random.seed(calcSeedFrom(chunk_id, seed, self.column_val))
        return np.random.choice(list(self.filters), length)


class ForcedSourceGenerator(ColumnGenerator):
    """Class to generate ForcedSource columns from Object and Visit tables.

    Parameters
    ----------
    filters : str
        String where each character is a valid filter id. These
        should probably match the values given to FilterGenerator.
    visit_radius : float
        Distance from the visit center within which and object is
        considered part of that visit.
    column_val : int
        Arbitrary integer that should be different from other
        column values. Used in random number generation.

    Note
    ----
    TODO: This is really slow. Checking all visits against all objects
    takes forever. Sorting visits by dec may help. It's also wonky in that
    visits with centers in neighboring chunks have no effect as they
    are unknown here. The case where an Object gets no visits may also
    be possible. Possibly visits should not be generated per chunk
    but across the visible sky as 100k visit table could be generated
    in a second or two and used for all chunks and tables.
    """

    def __init__(self, filters="ugrizy", visit_radius=0.30, column_val=3):
        self.filters = filters
        self.visit_radius = visit_radius
        self.column_val = column_val

    def __call__(self, chunk_id, length, seed, prereq_row=None, prereq_tables=None):
        assert prereq_row is not None, "ForcedSourceGenerator requires rows from Object."
        assert prereq_tables is not None, "ForcedSourceGenerator requires the Visit table."

        np.random.seed(calcSeedFrom(chunk_id, seed, self.column_val))

        visit_table = prereq_tables['CcdVisit']
        object_record = prereq_row

        # deltas - distance between 2 points on the sphere for everything in the table
        deltas = (SkyCoord(ra=visit_table['ra'], dec=visit_table['decl'], unit="deg")
                  .separation(SkyCoord(ra=object_record['ra'], dec=object_record['decl'],
                  unit="deg")).degree)
        n_matching_visits = np.sum(deltas < self.visit_radius)

        objectId = np.zeros(n_matching_visits, dtype=int) + int(object_record['objectId'])
        psFlux = np.random.randn(n_matching_visits)
        psFluxSigma = np.zeros(n_matching_visits) + 0.1
        ccdVisitId = np.zeros(n_matching_visits, dtype=int)

        index_position = 0
        for filter_name in self.filters:
            sel, = np.where((visit_table['filterName'] == filter_name) &
                            (deltas < self.visit_radius))

            matching_filter_visitIds = visit_table['ccdVisitId'][sel]

            if(len(matching_filter_visitIds) == 0):
                continue

            n_filter_visits = len(matching_filter_visitIds)
            output_indices = slice(index_position, index_position + n_filter_visits)
            ccdVisitId[output_indices] = matching_filter_visitIds
            psFlux[output_indices] += object_record['mag_{:s}'.format(filter_name)]
            index_position += n_filter_visits

        return (objectId, ccdVisitId, psFlux, psFluxSigma)


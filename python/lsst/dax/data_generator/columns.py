
import math
import numpy as np
from abc import ABC
import healpy

from astropy.coordinates import SkyCoord

from .chunker import Chunker




__all__ = ["ColumnGenerator", "ObjIdGenerator", "FilterGenerator",
           "RaDecGenerator", "MagnitudeGenerator", "ForcedSourceGenerator",
           "VisitIdGenerator"]


def calcSeedFrom(chunk_id, seed, column_val):
    """Try to keep some separation between column generator seeds.

    Parameters
    ----------
    chunk_id : int
        Chunk id number.
    seed : int
        Random number seed.
    column_val : int
        Arbitrary column value, should be different from other column values.

    Note
    ----
    This is an attempt to avoid having chunks and columns having seeds
    near each other so that changing the seed value by 1 will not look
    like everyting was just shifted over by 1 chunk/column.
    Each ColumnGenerator should have a unique arbitrary column_val.
    """
    return (chunk_id*10000 + seed + column_val*100)

def mergeBlocks(block_a, block_b):
    """Merge two block together where the lists should maintain the order of
    the individual elements.

    Parameters
    ----------
    block_a, block_b : tuple of lists
        Blocks of data generated by column generators.

    Return
    ------
    Tuple of lists
        Result of merging the two blocks.
    """
    newList = list()
    # There's probably a more pythonic way to do this.
    for j in range(len(block_a)):
        newList.append(np.append(block_a[j], block_b[j]))
    return tuple(newList)

def equalBlocks(block_a, block_b):
    """Each block should be a tuple of np.array. Return True if
    both blocks contain the same arrays in the same order.
    """
    if len(block_a) != len(block_b):
        return False
    for j in range(len(block_a)):
        a = block_a[j]
        b = block_b[j]
        if not np.array_equal(a, b):
            return False
    return True

def convertBlockToRows(block):
    """Transpose the block.

    Return
    ------
    tuple of lists
        A new block where columns of 'block' are the rows of the output block.
    """
    rows = list()
    rows_in_block = len(block[0])
    for j in range(rows_in_block):
        row = list()
        for x in block:
            if len(x) != rows_in_block:
                raise IndexError
            row.append(x[j])
        rows.append(row)
    return rows


def containsBlock(block_a, block_b):
    """Return True if every row in blockA has a matching row in blockB.
    The data is stored in columns and it is easier to do the
    comparison using rows.
    """
    if len(block_a) != len(block_b):
        return False
    if len(block_a) == 0:
        return True

    # Convert blockA into a list of rows.
    try:
        rows_a = convertBlockToRows(block_a)
        rows_b = convertBlockToRows(block_b)
        for row in rows_a:
            # if the row is found in rowsB, delete it in rowsB
            found = False
            for j in range(len(rows_b)):
                if row == rows_b[j]:
                    found = True
                    print("found row ", row)
                    del rows_b[j]
                    break
            if not found:
                print("missing row ", row)
                return False

    except IndexError:
        print("Malformed block A=", block_a, " B=", block_b)
        return False
    return True

class SimpleBox:
    """
    A simple RA DEC box where raA is always smaller than raB and decA is always smaller than decB and
    the units are degrees.

    Parameters
    ----------
    raA, raB : float
        RA of two opposite corners of the box.
    decA, decB : float
        Declination of two opposite corners of the box.

    Note
    ----
    This has no internal mechanism to fix wrap around from 360 to 0, so a
    box that includes lon 0 should go from -1 to 1 not 359 to 1.
    Dec values are constrained [-90, 90]
    """
    def __init__(self, raA, raB, decA, decB):
        self.raA = raA
        self.raB = raB
        self.decA = decA
        self.decB = decB
        if (raA > raB):
            tmp = raA
            raA = raB
            raB = tmp
        if (decA > decB):
            tmp = decA
            decA = decB
            decB = tmp
        if (decA > 90.0): decA = 90.0
        if (decA < -90.0): decA = -90.0
        if (decB > 90.0): decB = 90.0
        if (decB < -90.0): decB = -90.0


    def __repr__(self):
        return ('{raA=' + str(self.raA) + ' raB=' + str(self.raB) +
               ' decA=' + str(self.decA) + ' decB=' + str(self.decB) + '}')

    def __str__(self):
        return self.__repr__()

    def area(self):
        """
        Return
        ------
        area : float degrees
        Returns the approximate area of the box on a sphere, requires degrees
        """
        area = (self.raA - self.raB) * (self.decA - self.decB)
        avgDecDeg = (self.decA + self.decB) / 2
        avgDecRad = avgDecDeg * (math.pi/180.0)
        area = math.cos(avgDecRad) * area
        return area


class ColumnGenerator(ABC):

    def __call__(self, chunk_id, length, seed):
        """
        Parameters
        ----------
        chunk_id : int
            Identifier of which cell on the sky to in which
            coordinates should be generated
        length : int
            Number of coordiantes to generate
        seed : int
            Seed value for the random number generator to
            generate repeatable results.

        Returns
        -------
        columns: tuple
            One or more arrays containing the data for each column
        """
        return NotImplemented


class RaDecGenerator(ColumnGenerator):
    """This class generate pseudorandom repeatanble RA and Declination.


    Parameters
    ----------
    chunker : sphgeom.Chunker
        Chunker to provide RA and Dec limits of a chunk.
    ignore_edge_only : bool
        Generate the entire chunk's worth of RA and Dec even if edge_only
        is specified.

    Note
    ----
    It starts by generating edges first so edge_only and complete chunks
    will have matching edges.
    """
    def __init__(self, chunker, ignore_edge_only=False):
        self.chunker = chunker
        self.ignore_edge_only = ignore_edge_only
        self.columnVal = 1
        # avoid having the same ra and dec in different tables.
        if self.ignore_edge_only:
            self.columnVal = 2


    def _generateBlock(self, chunk_id, simple_box, length):
        """ Generate 'length' number of RA and Dec data entries for 'simpleBox'

        Parameters
        ----------
        chunk_id : int
            Chunk id number.
        simple_box : SimpleBox
            Defines min and max legal RA and Dec to be generated.

        Returns
        -------
        tuple of list of generated RA's and list of generated Dec's
        """
        ra_min = simple_box.raA
        ra_delta = simple_box.raB - simple_box.raA
        dec_min = simple_box.decA
        dec_delta = simple_box.decB - simple_box.decA
        ra_centers = np.random.random(length)*ra_delta + ra_min
        dec_centers = np.random.random(length)*dec_delta + dec_min
        ra_out = list()
        for ra in ra_centers:
            while ra < 0.0:
                ra += 360.0
            while ra >= 360.0:
                ra -= 360.0
            ra_out.append(ra)
        return (ra_out, dec_centers)

    def __call__(self, chunk_id, length, seed, edge_width, edge_only, prereq_tables=None, **kwargs):
        """
        Parameters
        ----------
        chunk_id : int
            Chunk id number where RA and Dec values are needed.
        length : int
            Number of coordiantes to generate.
        seed : int
            Random number seed.
        edge_width : float degrees
            Width of the edge generated. Must be wide enough to cover
            overlap and must be consistent throughout chunk generation.
        edge_only : bool
            When True, only generate the values near edges of chunks,
            edge_width. Otherwise, generate edge values first and then
            generate values for the middle of the chunk.
        prereq_tables, kwargs : ignored
            These values are not need by this generator, but other
            generators need them to work properly.

        Returns
        -------
        a tuple of a list of generated RA's and a list of generated Dec's.
        """
        np.random.seed(calcSeedFrom(chunk_id, seed, self.columnVal))

        # Some tables, such as ccdVisit, cannot be generated edgeOnly.
        if self.ignore_edge_only:
            edge_only = False

        # sphgeom Box from Chunker::getChunkBoundingBox
        chunk_box = self.chunker.getChunkBounds(chunk_id)
        # Need to correct for RA that crosses 0.
        raA = chunk_box.getLon().getA().asDegrees()
        raB = chunk_box.getLon().getB().asDegrees()
        ra_delta = raB - raA
        if ra_delta < 0:
            raA = raA - 360.0
            ra_delta = raB -raA
        decA = chunk_box.getLat().getA().asDegrees()
        decB = chunk_box.getLat().getB().asDegrees()

        boxes = {}
        entire_box = SimpleBox(raA, raB, decA, decB)
        boxes["entire"] = entire_box
        print("chunk=", chunk_id, "bbox=", entire_box.__repr__())

        if edge_width > 0.0:
            # Correct the edge_width for declination so there is at least
            # edge_width at both the top an bottom of the east and west blocks.
            edge_raA = edge_width / math.cos(decA + edge_width)
            edge_raB = edge_width / math.cos(decB - edge_width)
            edge_widthRA = max(edge_raA, edge_raB)

            boxes["north"] = SimpleBox(raA, raB, decB - edge_width, decB)
            boxes["east"] = SimpleBox(raA, raA + edge_widthRA, decA + edge_width, decB - edge_width)
            boxes["west"] = SimpleBox(raB - edge_widthRA, raB, decA + edge_width, decB - edge_width)
            boxes["south"] = SimpleBox(raA, raB, decA, decA + edge_width)

        # If the area of the entire box is only slightly larger than the sub-boxes,
        # don't bother with separate edge calculation
        edge_area = 0.0
        entire_area = 0.0
        for key, value in boxes.items():
            if key == "entire":
                entire_area = value.area()
            else:
                edge_area += value.area()

        ratio_edge_to_entire = edge_area/entire_area
        blocks = {}
        # TODO: replace 10 with minLength and 0.90 with maxRatioEdgeToEntire
        if (not edge_width > 0.0) or ratio_edge_to_entire > 0.90 or length < 10:
            # Just generate the entire block
            blocks["entire"] = self._generateBlock(chunk_id, boxes["entire"], length)
        else:
            lengths = {}
            sub_length = length
            for key, value in boxes.items():
                if key != "entire":
                    lengths[key] = int((value.area()/entire_area) * length)
                    if lengths[key] < 1:
                        lengths[key] = 1
                    sub_length -= lengths[key]
                    blocks[key] = self._generateBlock(chunk_id, boxes[key], lengths[key])
            blockNS = mergeBlocks(blocks["north"], blocks["south"])
            blockEW = mergeBlocks(blocks["east"], blocks["west"])
            blocks["entire"] = mergeBlocks(blockNS, blockEW)
            if not edge_only:
                box_middle = SimpleBox(boxes["east"].raB, boxes["west"].raA,
                                       boxes["north"].decB, boxes["south"].decA)
                block_middle = self._generateBlock(chunk_id, box_middle, sub_length)
                blocks["entire"] = mergeBlocks(blocks["entire"], block_middle)
        return blocks["entire"]


class ObjIdGenerator(ColumnGenerator):

    def __call__(self, chunk_id, length, seed, **kwargs):
        """
        Returns
        -------
        object_id : array
            Array containing unique IDs for each object
        """

        # TODO: more than 100k objects in a chunk will cause issues
        #       Replace 100000 with max_objects_per_chunk?
        return (chunk_id * 100000) + np.arange(length)


class VisitIdGenerator(ColumnGenerator):

    def __call__(self, chunk_id, length, seed, **kwargs):
        """
        Returns
        -------
        visit_id : array
            Array containing unique IDs for each visit
        """

        # TODO: This shouldn't have the same issue as objects/chunk
        #       but maybe replace 100000 with max_objects_per_chunk?
        return 10000000000 + (chunk_id * 100000) + np.arange(length)


class MagnitudeGenerator(ColumnGenerator):
    """
    Parameters
    ----------
    n_mags : int
        Number of magnitude columns to make.
    min_mag : float
        Minimum value for generated magnitudes.
    max_mag : float
        Maximum value for generated magnitudes.
    column_val : int
        Arbitrary integer that should be different from other
        column values. Used in random number generation.

    Note
    ----
    Currently generates a flat magnitude distribution. Should properly
    be some power law.
    If there is more than one call to this in a single table, there will
    be correlation between rows as the same random numbers will be used.
    """

    def __init__(self, n_mags=1, min_mag=0, max_mag=27.5, column_val=7):
        self.n_mags = n_mags
        self.min_mag = min_mag
        self.max_mag = max_mag
        self.column_val = column_val  # arbitrary, but different from other columns

    def __call__(self, chunk_id, length, seed, **kwargs):

        np.random.seed(calcSeedFrom(chunk_id, seed, self.column_val))

        # This needs to be made row by row not column by column, as
        # row by row results in repeatable values when doing edges first.
        magRows = list()
        delta_mag = self.max_mag - self.min_mag
        for j in range(length):
            mag = np.random.rand(self.n_mags)*delta_mag + self.min_mag
            magRows.append(mag)
        magCols = convertBlockToRows(magRows)
        return magCols


class FilterGenerator(ColumnGenerator):
    """Class to generate random filter columns.

    Parameters
    ----------
    filters : str
        String where each character is a valid filter id.
    column_val : int
        Arbitrary integer that should be different from other
        column values. Used in random number generation.
    """

    def __init__(self, filters="ugrizy", column_val=6):
        self.filters = filters
        self.column_val = column_val

    def __call__(self, chunk_id, length, seed, **kwargs):
        np.random.seed(calcSeedFrom(chunk_id, seed, self.column_val))
        return np.random.choice(list(self.filters), length)


class ForcedSourceGenerator(ColumnGenerator):
    """Class to generate ForcedSource columns from Object and Visit tables.

    Parameters
    ----------
    filters : str
        String where each character is a valid filter id. These
        should probably match the values given to FilterGenerator.
    visit_radius : float
        Distance from the visit center within which and object is
        considered part of that visit.
    column_val : int
        Arbitrary integer that should be different from other
        column values. Used in random number generation.

    Note
    ----
    TODO: This is really slow. Checking all visits against all objects
    takes forever. Sorting visits by dec may help. It's also wonky in that
    visits with centers in neighboring chunks have no effect as they
    are unknown here. The case where an Object gets no visits may also
    be possible. Possibly visits should not be generated per chunk
    but across the visible sky as 100k visit table could be generated
    in a second or two and used for all chunks and tables.
    """

    def __init__(self, filters="ugrizy", visit_radius=0.30, column_val=3):
        self.filters = filters
        self.visit_radius = visit_radius
        self.column_val = column_val

    def __call__(self, chunk_id, length, seed, prereq_row=None, prereq_tables=None):
        assert prereq_row is not None, "ForcedSourceGenerator requires rows from Object."
        assert prereq_tables is not None, "ForcedSourceGenerator requires the Visit table."

        np.random.seed(calcSeedFrom(chunk_id, seed, self.column_val))

        visit_table = prereq_tables['CcdVisit']
        object_record = prereq_row

        # deltas - distance between 2 points on the sphere for everything in the table
        deltas = (SkyCoord(ra=visit_table['ra'], dec=visit_table['decl'], unit="deg")
                .separation(SkyCoord(ra=object_record['ra'], dec=object_record['decl'], unit="deg")).degree)
        n_matching_visits = np.sum(deltas < self.visit_radius)


        objectId = np.zeros(n_matching_visits, dtype=int) + int(object_record['objectId'])
        psFlux = np.random.randn(n_matching_visits)
        psFluxSigma = np.zeros(n_matching_visits) + 0.1
        ccdVisitId = np.zeros(n_matching_visits, dtype=int)

        index_position = 0
        for filter_name in self.filters:
            sel, = np.where((visit_table['filterName'] == filter_name) &
                            (deltas < self.visit_radius))

            matching_filter_visitIds = visit_table['ccdVisitId'][sel]

            if(len(matching_filter_visitIds) == 0):
                continue

            n_filter_visits = len(matching_filter_visitIds)
            output_indices = slice(index_position, index_position + n_filter_visits)
            ccdVisitId[output_indices] = matching_filter_visitIds
            psFlux[output_indices] += object_record['mag_{:s}'.format(filter_name)]
            index_position += n_filter_visits

        return (objectId, ccdVisitId, psFlux, psFluxSigma)


def tst_convertBlockToRows(log_msgs=True):
    """Test convertBlockToRows.

    Paramters
    ---------
    log_msgs : bool
        True if non-error messages should be printed.

    Return
    ------
    success : bool
        True when the test was successful.
    """
    vals1 = np.array([101, 102, 103])
    vals2 = np.array([309, 308, 307])
    vals3 = np.array([951, 952, 953])
    blockA = (vals1, vals2, vals3)
    rows_expected = list()
    rows_expected.append(list([101, 309, 951]))
    rows_expected.append(list([102, 308, 952]))
    rows_expected.append(list([103, 307, 953]))
    rowsA = convertBlockToRows(blockA)
    if log_msgs:
        print("rowsA=", rowsA)
        print("expected=", rows_expected)
    if rowsA != rows_expected:
        print("FAILED rows did not match a=", rowsA, " expected=", rows_expected)
        return False
    return True

def tst_mergeBlocks(log_msgs=True):
    """Test mergeBlocks

    Paramters
    ---------
    log_msgs : bool
        True if non-error messages should be printed.

    Return
    ------
    success : bool
        True when the test was successful.
    """
    vals1 = np.array([101, 102, 103, 104, 105])
    vals2 = np.array([309, 308, 307, 306, 305])
    vals3 = np.array([951, 952, 953, 954, 955])
    blockA = (vals1, vals2, vals3)
    vals4 = np.array([201, 202, 203, 204, 205, 207])
    vals5 = np.array([609, 608, 607, 606, 605, 604])
    vals6 = np.array([751, 752, 753, 754, 755, 756])
    blockB = (vals4, vals5, vals6)
    blockC = mergeBlocks(blockA, blockB)
    if log_msgs:
        print("blockA=",blockA)
        print("blockB=",blockB)
        print("blockC=",blockC)
    expected1 = np.array([101, 102, 103, 104, 105, 201, 202, 203, 204, 205, 207])
    expected2 = np.array([309, 308, 307, 306, 305, 609, 608, 607, 606, 605, 604])
    expected3 = np.array([951, 952, 953, 954, 955, 751, 752, 753, 754, 755, 756])
    block_expected = (expected1, expected2, expected3)
    success = None
    if not equalBlocks(blockC, block_expected):
        print("FAILED blocks do not match expected=", block_expected, " C=", blockC)
        success = False
    bad3 = np.array([951, 952, 953, 954, 955, 751, 752, 753, 754, 375, 756])
    block_bad = (expected1, expected2, bad3)
    if equalBlocks(blockC, block_bad):
        print("FAILED to detect differences in blocks bad=", block_bad, " C=", blockC)
        success = False
    if not containsBlock(blockA, blockC):
        print("FAILED blockA should have been found in blockC A=", blockA, " C=", blockC)
        success = False
    if containsBlock(block_bad, block_expected):
        print("FAILED blockBad should not have been found in blockExpected bad=", block_bad,
              "ex=", block_expected)
        success = False
    # check for duplicate row
    blockBad2 = (np.array([101, 101]), np.array([309, 309]), np.array([951, 951]))
    if containsBlock(blockBad2, blockC):
        print("FAILED blockBad2 should not have been found in blockC bad=", block_bad,
              "C=", blockC)
        success = False

    if success is None:
        success = True
    return success


def tst_RaDecGenerator(log_msgs=True, every_nth=75):
    """Test RaDecGenerator.

    Paramters
    ---------
    log_msgs : bool
        True if non-error messages should be printed.
    every_nth : int
        Starting from 0, every_nth valid chunk id number
        and the last valid chunk number will be used in
        the test. This gets both poles and a fair number
        of other chunks in between.

    Return
    ------
    success : bool
        True when the test was successful.
    """
    success = None
    # setup chunking information
    num_stripes = 200
    num_substripes = 5
    localChunker = Chunker(0, num_stripes, num_substripes)

    allChunks = localChunker.getAllChunks()
    if log_msgs: print("allChunks=", len(allChunks))
    many_chunks = allChunks[0::every_nth]
    # Get both north and south pole chunks.
    if many_chunks[-1] != allChunks[-1]:
        many_chunks.append(allChunks[-1])
    length = 10000
    # a bit more than an arcminute for edge_width.
    edge_width = 0.017
    col_gen = RaDecGenerator(localChunker)
    seed = 1
    blocksA = {}
    for chunk_id in many_chunks:
        blocksA[chunk_id] = col_gen(chunk_id, length, seed, edge_width, edge_only=False)
        if log_msgs: print("blocksA[", chunk_id, "]=", blocksA[chunk_id])

    blocksB = {}
    for chunk_id in many_chunks:
        blocksB[chunk_id] = col_gen(chunk_id, length, seed, edge_width, edge_only=False)
        if log_msgs: print("blocksB[", chunk_id, "]=", blocksB[chunk_id])

    blocksC = {}
    for chunk_id in many_chunks:
        blocksC[chunk_id] = col_gen(chunk_id, length, seed, edge_width, edge_only=True)
        if log_msgs: print("blocksC[", chunk_id, "]=", blocksC[chunk_id])

    blocksD = {}
    for chunk_id in many_chunks:
        blocksD[chunk_id] = col_gen(chunk_id, length, seed, edge_width, edge_only=True)
        if log_msgs: print("blocksD[", chunk_id, "]=", blocksD[chunk_id])

    for chunk_id in many_chunks:
        blockA = blocksA[chunk_id]
        blockB = blocksB[chunk_id]
        if not equalBlocks(blockA, blockB):
            print("FAILED blocks not equal chunk_id=", chunk_id)
            success = False
        blockC = blocksC[chunk_id]
        blockD = blocksD[chunk_id]
        if not equalBlocks(blockC, blockD):
            print("FAILED edgeOnly blocks not equal chunk_id=", chunk_id)
            success = False
        if not containsBlock(blockC, blockA):
            print("FAILED edgeOnly blocks not found in larger block chunk_id=", chunk_id)

    if success is None:
        success = True
    return success

